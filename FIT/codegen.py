# Copyright 2019 Joan Puig
# See LICENSE for details
import importlib
import inspect
import keyword
from typing import Dict, Iterable, Optional

from FIT import duplicates
from FIT.profile import Profile
from pathlib import Path
from FIT.base_types import BASE_TYPE_NAME_MAP


class CodeWriterError(Exception):
    pass


class CodeWriter:
    def __init__(self):
        self.indent_count = 0
        self.content = ''
        self.in_fragment = False

    def indent(self):
        if self.in_fragment:
            raise CodeWriterError('Cannot indent while writing a line fragment')
        self.indent_count = self.indent_count + 1

    def unindent(self):
        if self.in_fragment:
            raise CodeWriterError('Cannot unindent while writing a line fragment')
        self.indent_count = self.indent_count - 1

    def write(self, code: str, *args):
        self.write_fragment(code, *args)
        self.new_line()

    def new_line(self, lines: int = 1):
        self.content = self.content + ('\n'*lines).format()
        self.in_fragment = False

    def write_fragment(self, code: str, *args):
        if args:
            code = code.format(*args)

        if self.in_fragment:
            self.content = self.content + code
        else:
            self.content = self.content + ('\t'*self.indent_count).format() + code

        self.in_fragment = True

    def write_to_file(self, file_name: str):
        if self.in_fragment:
            self.new_line()

        with open(file_name, 'w') as file:
            file.write(self.content)


class CodeGeneratorError(Exception):
    pass


class CodeGenerator:
    DEFAULT_UNIT_SYNONYMS = {
        '2 * cycles (steps)': 'two_cycles_steps',
        '100 * m': 'length_100_m',
        'm/s,\nm': 'm_per_s_and_m',

        'min': 'minutes',
        'deg/s': 'degrees/s',

        'C': 'degrees_celsius',
        'if': 'intensity_factor',
        'tss': 'training_stress_score',
        'mmHg': 'mm_Hg',
        '': 'dimensionless',
    }

    def __init__(self, profile: Profile, code_writer: CodeWriter, unit_synonyms: Dict[str, str] = None):
        self.profile = profile

        if code_writer:
            self.code_writer = code_writer
        else:
            self.code_writer = CodeWriter()

        if unit_synonyms:
            self.unit_synonyms = unit_synonyms
        else:
            self.unit_synonyms = CodeGenerator.DEFAULT_UNIT_SYNONYMS

    def generate_header(self):
        cw = self.code_writer
        cw.write('# Copyright 2019 Joan Puig')
        cw.write('# See LICENSE for details')
        cw.new_line()
        cw.write('# Generated by {} in {}', self.__class__.__name__, Path(__file__).name)

    @staticmethod
    def capitalize_type_name(name: str) -> str:
        return ''.join(c[0].capitalize() + c[1:] for c in name.split('_'))

    @staticmethod
    def check_valid_name(name: str) -> None:
        if not name:
            raise CodeGeneratorError('Name is empty')
        if keyword.iskeyword(name):
            raise CodeGeneratorError(f'Name {name} is a keyword')
        if name[0].isdigit():
            raise CodeGeneratorError(f'Name {name} starts with a digit')

    @staticmethod
    def generate(code_generator, profile: Profile, output_file: Optional[str] = None) -> str:
        code_generator.generate_full()

        if output_file:
            code_generator.code_writer.write_to_file(output_file)

        return code_generator.code_writer.content


class TypeCodeGenerator(CodeGenerator):

    DEFAULT_INVALID_VALUE_NAME_IDENTIFIERS = {
        'None': 'Null',
        '4iiiis': 'Innovations4iiiis',
        '1partcarbon': 'OnePartCarbon',
        '3WayCalfRaise': 'ThreeWayCalfRaise',
        '3WayWeightedCalfRaise': 'ThreeWayWeightedCalfRaise',
        '3WaySingleLegCalfRaise': 'ThreeWaySingleLegCalfRaise',
        '3WayWeightedSingleLegCalfRaise': 'ThreeWayWeightedSingleLegCalfRaise',
        '45DegreeCableExternalRotation': 'FortyFiveDegreeCableExternalRotation',
        '45DegreePlank': 'FortyFiveDegreePlank',
        '90DegreeStaticHold': 'NinetyDegreeStaticHold',
        '30DegreeLatPulldown': 'ThirtyDegreeLatPulldown',
        '90DegreeCableExternalRotation': 'NinetyDegreeCableExternalRotation',
    }

    DEFAULT_FREE_RANGE_TYPES = (
        'MessageIndex',
        'UserLocalId',
        'FitBaseUnit',
        'DateTime',
        'LocalDateTime',
        'DeviceIndex'
    )

    DEFAULT_MISSING_MESSAGE_DEFINITIONS = (
        'Pad'
    )

    def __init__(self, profile: Profile, code_writer: CodeWriter = None, unit_synonyms: Dict[str, str] = None, invalid_value_identifiers: Dict[str, str] = None, free_range_types: Iterable[str] = None, missing_message_definitions: Iterable[str] = None):
        super().__init__(profile, code_writer, unit_synonyms)

        if invalid_value_identifiers:
            self.invalid_value_name_identifiers = invalid_value_identifiers
        else:
            self.invalid_value_name_identifiers = TypeCodeGenerator.DEFAULT_INVALID_VALUE_NAME_IDENTIFIERS

        if free_range_types:
            self.free_range_types = free_range_types
        else:
            self.free_range_types = TypeCodeGenerator.DEFAULT_FREE_RANGE_TYPES

        if missing_message_definitions:
            self.missing_message_definitions = missing_message_definitions
        else:
            self.missing_message_definitions = TypeCodeGenerator.DEFAULT_MISSING_MESSAGE_DEFINITIONS

    def generate_full(self):
        self.generate_header()
        self.code_writer.new_line(2)
        self.generate_imports()
        self.code_writer.new_line(2)
        self.generate_units()
        self.code_writer.new_line(2)
        self.generate_types()

    def generate_imports(self):
        cw = self.code_writer
        cw.write('from enum import Enum, auto')
        cw.new_line()
        cw.write('from FIT.base_types import SignedInt8, SignedInt16, SignedInt32, SignedInt64')
        cw.write('from FIT.base_types import UnsignedInt8, UnsignedInt16, UnsignedInt32, UnsignedInt64')
        cw.write('from FIT.base_types import UnsignedInt8z, UnsignedInt16z, UnsignedInt32z, UnsignedInt64z')
        cw.write('from FIT.base_types import FITEnum, String, Float32, Float64, Byte')

    def generate_units(self):
        cw = self.code_writer
        messages = self.profile.messages

        # Extract the units in all the fields of all the messages listed in the profile without repetitions
        units = {field.units for message in messages for field in message.fields}
        units.add('invalid')

        # The profile file provided in the SDK has inconsistent names for units, the following code cleans them up
        unnecessary_synonyms = [key for key in self.unit_synonyms.keys() if key not in units]
        if unnecessary_synonyms:
            raise CodeGeneratorError(f'Synonyms for units not in the profile were provided {", ".join(unnecessary_synonyms)}')
        # Apply the synonyms
        units = {self.unit_synonyms.get(unit, unit) for unit in units}

        # Replace some illegal characters in the unit names
        cleaner = lambda u: u.replace(' ', '_').replace('^', '').replace('/', '_per_').replace('%', 'percent')

        units = list({cleaner(unit) for unit in units})

        units.sort(key=str.lower)

        cw.write('class Unit(Enum):')
        cw.indent()
        for unit in units:
            CodeGenerator.check_valid_name(unit)
            cw.write(f'{unit} = auto()')

        cw.new_line()
        cw.write('@staticmethod')
        cw.write(f'def from_string(unit: str) -> "Unit":')
        cw.indent()
        cw.write('unit_synonyms = {')
        cw.indent()
        for (k, v) in self.unit_synonyms.items():
            cw.write('\'{}\': \'{}\',', k.replace('\n', '\\n'), v)
        cw.unindent()
        cw.write('}')
        cw.new_line()
        cw.write('unit = unit_synonyms.get(unit, unit)')
        cw.write(str(inspect.getsourcelines(cleaner)[0]).strip("['\\n']")[9:-3])
        cw.write('unit = cleaner(unit)')
        cw.write('return Unit._value2member_map_.get(unit, Unit.invalid)')
        cw.unindent()
        cw.unindent()

    def generate_types(self):
        cw = self.code_writer
        types = self.profile.types

        for type_profile in types:
            type_name = CodeGenerator.capitalize_type_name(type_profile.name)
            CodeGenerator.check_valid_name(type_name)

            cw.write(f'# FIT type name: {type_profile.name}')
            if type_profile.comment:
                cw.write(f'# {type_profile.comment}')

            has_named_values = len(type_profile.values) > 0
            if not has_named_values:
                cw.write(f'class {type_name}({BASE_TYPE_NAME_MAP[type_profile.base_type]}):')
                cw.indent()
                cw.write('pass')

            else:
                if type_name in self.free_range_types:
                    cw.write(f'class {type_name}({BASE_TYPE_NAME_MAP[type_profile.base_type]}):')
                else:
                    cw.write(f'class {type_name}(Enum):')

                cw.indent()

                has_invalid = False
                has_invalid_value = False
                mod = importlib.import_module('FIT.messages')
                type_class = getattr(mod, BASE_TYPE_NAME_MAP[type_profile.base_type])
                parent_type_invalid_value = type_class.metadata.invalid_value
                resolved_values = []
                for value in type_profile.values:
                    value_name = CodeGenerator.capitalize_type_name(value.name)
                    value_name = self.invalid_value_name_identifiers.get(value_name, value_name)
                    CodeGenerator.check_valid_name(value_name)

                    if type_name != 'MesgNum' or value_name not in self.missing_message_definitions:
                        if type(value.value) == str:
                            value_str = f'{value.value}'
                            if int(value.value, 0) == parent_type_invalid_value:
                                has_invalid_value = True
                        else:
                            value_str = f'{int(value.value):d}'
                            if int(value.value) == parent_type_invalid_value:
                                has_invalid_value = True

                        resolved_values.append({
                            'value_name': value_name,
                            'base_type': BASE_TYPE_NAME_MAP[type_profile.base_type],
                            'value_str': value_str,
                            'original_value_name': value.name,
                            'comment': value.comment}
                        )

                        if value_name == 'Invalid':
                            has_invalid = True

                duplicate_value_names = duplicates([v['value_name'] for v in resolved_values])
                if duplicate_value_names:
                    raise CodeGeneratorError(f'Type {type_name} has duplicate value names: {", ".join(duplicate_value_names)}')

                if not has_invalid and not has_invalid_value:
                    resolved_values.append({
                        'value_name': 'Invalid',
                        'base_type': BASE_TYPE_NAME_MAP[type_profile.base_type],
                        'value_str': f'{parent_type_invalid_value}',
                        'original_value_name': 'Invalid',
                        'comment': 'Invalid value'}
                    )

                max_name_length = max([len(resolved_value['value_name']) for resolved_value in resolved_values])
                max_value_length = max([len(resolved_value['value_str']) for resolved_value in resolved_values])
                max_original_name_length = max([len(resolved_value['original_value_name']) for resolved_value in resolved_values])
                fmt = '{:<' + str(max_name_length) + '} = {}({:>' + str(max_value_length) + '})  # {:<' + str(max_original_name_length) + '}'

                for resolved_value in resolved_values:
                    cw.write_fragment(fmt, resolved_value['value_name'], resolved_value['base_type'], resolved_value['value_str'], resolved_value['original_value_name'])
                    if resolved_value['comment']:
                        cw.write(f' - {resolved_value["comment"]}')
                    else:
                        cw.write('')

            cw.unindent()
            cw.new_line(2)

    @staticmethod
    def generate(profile: Profile, output_file:  Optional[str] = None, **kwargs) -> str:
        code_generator = TypeCodeGenerator(profile, **kwargs)
        return CodeGenerator.generate(code_generator, profile, output_file)


class MessageCodeGenerator(CodeGenerator):

    def __init__(self, profile: Profile, code_writer: CodeWriter = None):
        super().__init__(profile, code_writer)

    def generate_full(self):
        self.generate_header()
        self.code_writer.new_line(2)
        self.generate_imports()
        self.code_writer.new_line(2)
        self.generate_messages()

    def generate_imports(self):
        cw = self.code_writer
        cw.write('import warnings')
        cw.write('from typing import Tuple, Dict')
        cw.write('from enum import Enum, auto')
        cw.write('from dataclasses import dataclass')
        cw.new_line()
        cw.write('from FIT.base_types import SignedInt8, SignedInt16, SignedInt32, SignedInt64')
        cw.write('from FIT.base_types import UnsignedInt8, UnsignedInt16, UnsignedInt32, UnsignedInt64')
        cw.write('from FIT.base_types import UnsignedInt8z, UnsignedInt16z, UnsignedInt32z, UnsignedInt64z')
        cw.write('from FIT.base_types import FITEnum, String, Float32, Float64, Byte')
        cw.new_line()
        cw.write('import FIT.types')
        cw.write('from FIT.model import Record, Message, MessageDefinition, FieldDefinition, RecordField')
        cw.write('from FIT.decoder import extract_value')

    def generate_messages(self):
        cw = self.code_writer
        messages = self.profile.messages

        for message in messages:
            message_name = CodeGenerator.capitalize_type_name(message.name)
            cw.write('@dataclass(frozen=True)')
            cw.write(f'# FIT message name: {message.name}')
            cw.write(f'class {message_name}(Message):')
            cw.indent()

            resolved_fields = []
            for field in message.fields:
                CodeGenerator.check_valid_name(field.name)

                resolved_field = {
                    'name': field.name,
                    'type': 'FIT.types.' + CodeGenerator.capitalize_type_name(BASE_TYPE_NAME_MAP.get(field.type, field.type)),
                    'comment': field.comment,
                    'is_scalar': not field.array,
                    'number': field.number
                }

                if field.type == 'bool':
                    resolved_field['type'] = 'bool'

                if not resolved_field['is_scalar'] and not resolved_field['type'] == 'String':
                    resolved_field['type'] = f'Tuple[{resolved_field["type"]}]'

                resolved_fields.append(resolved_field)

            duplicate_field_names = duplicates([v['name'] for v in resolved_fields])
            if duplicate_field_names:
                raise CodeGeneratorError(f'Message {message_name} has duplicate value names: {", ".join(duplicate_field_names)}')

            max_name_length = max([len(resolved_field['name']) for resolved_field in resolved_fields])
            max_type_length = max([len(resolved_field['type']) for resolved_field in resolved_fields])

            for resolved_field in resolved_fields:
                CodeGenerator.check_valid_name(resolved_field['name'])
                cw.write_fragment('{:<' + str(max_name_length) + '} : {:<' + str(max_type_length) + '}', resolved_field['name'], resolved_field['type'])
                if resolved_field['comment']:
                    cw.write(f'    # {resolved_field["comment"]}')
                else:
                    cw.write('')

            cw.new_line()
            cw.write('@staticmethod')
            cw.write(f'def from_record(record: Record, message_definition: MessageDefinition, error_on_invalid_enum_value: bool = True) ->  "{message_name}":')
            cw.indent()
            cw.write('developer_fields = Message.developer_fields_from_record(record, message_definition, error_on_invalid_enum_value)')
            cw.write('undocumented_fields = Message.undocumented_fields_from_record(record.content, message_definition, ({}), error_on_invalid_enum_value)', ', '.join([str(field.number) for field in message.fields if field.number is not None]))
            cw.write('field_map = message_definition.mapped_field_definitions()')
            cw.write('fields = record.content.fields')
            cw.write('mn = \'{}\'', message_name)
            cw.new_line()

            for resolved_field in resolved_fields:
                if resolved_field['type'].startswith('Tuple['):
                    resolved_field['type'] = 'None'  # TODO: handle arrays
                cw.write('{} = extract_value(mn, \'{}\', {}, field_map, fields, {}, error_on_invalid_enum_value)', resolved_field['name'], resolved_field['name'], resolved_field['number'], resolved_field['type'])
            cw.write('return {}({})', message_name, ', '.join(['developer_fields', 'undocumented_fields'] + [resolved_field['name'] for resolved_field in resolved_fields]))
            cw.unindent()
            cw.unindent()

            cw.new_line(2)

    @staticmethod
    def generate(profile: Profile, output_file: Optional[str] = None, **kwargs) -> str:
        code_generator = MessageCodeGenerator(profile, **kwargs)
        return CodeGenerator.generate(code_generator, profile, output_file)
