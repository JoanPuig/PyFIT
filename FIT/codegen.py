# Copyright 2019 Joan Puig
# See LICENSE for details


import inspect
import keyword
from typing import Dict, List, Set

from FIT import duplicates
from FIT.profile import Profile
from pathlib import Path
from FIT.base_types import BASE_TYPE_NAME_MAP


class CodeWriterError(Exception):
    pass


class CodeWriter:
    def __init__(self):
        self.indent_count = 0
        self.content = ''
        self.in_fragment = False

    def indent(self):
        if self.in_fragment:
            raise CodeWriterError('Cannot indent while writing a line fragment')
        self.indent_count = self.indent_count + 1

    def unindent(self):
        if self.in_fragment:
            raise CodeWriterError('Cannot unindent while writing a line fragment')
        self.indent_count = self.indent_count - 1

    def write(self, code: str, *args):
        self.write_fragment(code, *args)
        self.new_line()

    def new_line(self, lines: int = 1):
        self.content = self.content + ('\n'*lines).format()
        self.in_fragment = False

    def write_fragment(self, code: str, *args):
        if args:
            code = code.format(*args)

        if self.in_fragment:
            self.content = self.content + code
        else:
            self.content = self.content + ('\t'*self.indent_count).format() + code

        self.in_fragment = True

    def write_to_file(self, file_name: str):
        if self.in_fragment:
            self.new_line()

        with open(file_name, 'w') as file:
            file.write(self.content)


class CodeGeneratorError(Exception):
    pass


class CodeGenerator:
    DEFAULT_UNIT_SYNONYMS = {
        '2 * cycles (steps)': 'two_cycles_steps',
        '100 * m': 'length_100_m',
        'm/s,\nm': 'm_per_s_and_m',

        'min': 'minutes',
        'deg/s': 'degrees/s',

        'C': 'degrees_celsius',
        'if': 'intensity_factor',
        'tss': 'training_stress_score',
        'mmHg': 'mm_Hg',
        '': 'dimensionless',
    }

    DEFAULT_INVALID_VALUE_NAME_IDENTIFIERS = {
        'None': 'Null',
        '4iiiis': 'Innovations4iiiis',
        '1partcarbon': 'OnePartCarbon',
        '3WayCalfRaise': 'ThreeWayCalfRaise',
        '3WayWeightedCalfRaise': 'ThreeWayWeightedCalfRaise',
        '3WaySingleLegCalfRaise': 'ThreeWaySingleLegCalfRaise',
        '3WayWeightedSingleLegCalfRaise': 'ThreeWayWeightedSingleLegCalfRaise',
        '45DegreeCableExternalRotation': 'FortyFiveDegreeCableExternalRotation',
        '45DegreePlank': 'FortyFiveDegreePlank',
        '90DegreeStaticHold': 'NinetyDegreeStaticHold',
        '30DegreeLatPulldown': 'ThirtyDegreeLatPulldown',
        '90DegreeCableExternalRotation': 'NinetyDegreeCableExternalRotation',
    }

    DEFAULT_FREE_RANGE_TYPES = [
        'MessageIndex',
        'UserLocalId',
        'FitBaseUnit',
        'DateTime',
        'LocalDateTime',
        'DeviceIndex'
    ]

    DEFAULT_MISSING_MESSAGE_DEFINITIONS = [
        'Pad'
    ]

    def __init__(self, profile: Profile, code_writer: CodeWriter = None, unit_synonyms: Dict[str, str] = None, invalid_value_identifiers: Dict[str, str] = None, free_range_types: List[str] = None, missing_message_definitions: List[str] = None):
        self.profile = profile

        if code_writer:
            self.code_writer = code_writer
        else:
            self.code_writer = CodeWriter()

        if unit_synonyms:
            self.unit_synonyms = unit_synonyms
        else:
            self.unit_synonyms = CodeGenerator.DEFAULT_UNIT_SYNONYMS

        if invalid_value_identifiers:
            self.invalid_value_name_identifiers = invalid_value_identifiers
        else:
            self.invalid_value_name_identifiers = CodeGenerator.DEFAULT_INVALID_VALUE_NAME_IDENTIFIERS

        if free_range_types:
            self.free_range_types = free_range_types
        else:
            self.free_range_types = CodeGenerator.DEFAULT_FREE_RANGE_TYPES

        if missing_message_definitions:
            self.missing_message_definitions = missing_message_definitions
        else:
            self.missing_message_definitions = CodeGenerator.DEFAULT_MISSING_MESSAGE_DEFINITIONS

    def generate_full(self):
        self.generate_header()
        self.code_writer.new_line(2)
        self.generate_imports()
        self.code_writer.new_line(2)
        self.generate_units()
        self.code_writer.new_line(2)
        self.generate_types()
        self.code_writer.new_line(2)
        self.generate_messages()

    def generate_header(self):
        cw = self.code_writer
        cw.write('# Copyright 2019 Joan Puig')
        cw.write('# See LICENSE for details')
        cw.new_line()
        cw.write('# Generated by {} in {}', self.__class__.__name__, Path(__file__).name)

    def generate_imports(self):
        cw = self.code_writer
        cw.write('from typing import Tuple')
        cw.write('from enum import Enum, auto')
        cw.write('from dataclasses import dataclass')
        cw.new_line()
        cw.write('from FIT.base_types import SignedInt8, SignedInt16, SignedInt32, SignedInt64')
        cw.write('from FIT.base_types import UnsignedInt8, UnsignedInt16, UnsignedInt32, UnsignedInt64')
        cw.write('from FIT.base_types import UnsignedInt8z, UnsignedInt16z, UnsignedInt32z, UnsignedInt64z')
        cw.write('from FIT.base_types import FITEnum, String, Float32, Float64, Byte')
        cw.new_line()
        cw.write('from FIT.model import Record, Message, MessageDefinition')

    def generate_units(self):
        cw = self.code_writer
        messages = self.profile.messages

        # Extract the units in all the fields of all the messages listed in the profile without repetitions
        units = {field.units for message in messages for field in message.fields}
        units.add('invalid')

        # The profile file provided in the SDK has inconsistent names for units, the following code cleans them up
        unnecessary_synonyms = [key for key in self.unit_synonyms.keys() if key not in units]
        if unnecessary_synonyms:
            raise CodeGeneratorError('Synonyms for units not in the profile were provided {}'.format(', '.join(unnecessary_synonyms)))
        # Apply the synonyms
        units = {self.unit_synonyms.get(unit, unit) for unit in units}

        # Replace some illegal characters in the unit names
        cleaner = lambda u: u.replace(' ', '_').replace('^', '').replace('/', '_per_').replace('%', 'percent')

        units = list({cleaner(unit) for unit in units})

        units.sort(key=str.lower)

        cw.write('class Unit(Enum):')
        cw.indent()
        for unit in units:
            CodeGenerator.check_valid_name(unit)
            cw.write('{} = auto()'.format(unit))

        cw.new_line()
        cw.write('@staticmethod')
        cw.write('def from_string(unit: str):')  # TODO add type hint
        cw.indent()
        cw.write('unit_synonyms = {')
        cw.indent()
        for (k, v) in self.unit_synonyms.items():
            cw.write('\'{}\': \'{}\',', k.replace('\n', '\\n'), v)
        cw.unindent()
        cw.write('}')
        cw.new_line()
        cw.write('unit = unit_synonyms.get(unit, unit)')
        cw.write(str(inspect.getsourcelines(cleaner)[0]).strip("['\\n']")[9:-3])
        cw.write('unit = cleaner(unit)')
        cw.write('return Unit._value2member_map_.get(unit, Unit.invalid)')
        cw.unindent()
        cw.unindent()

    def generate_types(self):
        cw = self.code_writer
        types = self.profile.types

        for type_profile in types:
            type_name = CodeGenerator.capitalize_type_name(type_profile.name)
            CodeGenerator.check_valid_name(type_name)

            cw.write('# FIT type name: {}', type_profile.name)
            if type_profile.comment:
                cw.write('# {}', type_profile.comment)

            has_named_values = len(type_profile.values) > 0
            if not has_named_values:
                cw.write('class {}({}):', type_name, BASE_TYPE_NAME_MAP[type_profile.base_type])
                cw.indent()
                cw.write('pass')

            else:
                if type_name in self.free_range_types:
                    cw.write('class {}({}):', type_name, BASE_TYPE_NAME_MAP[type_profile.base_type])
                else:
                    cw.write('class {}(Enum):', type_name)

                cw.indent()

                resolved_values = []
                for value in type_profile.values:
                    value_name = CodeGenerator.capitalize_type_name(value.name)
                    value_name = self.invalid_value_name_identifiers.get(value_name, value_name)
                    CodeGenerator.check_valid_name(value_name)

                    if type_name != 'MesgNum' or value_name not in self.missing_message_definitions:
                        if type(value.value) == str:
                            value_str = "{}".format(value.value)
                        else:
                            value_str = '{:d}'.format(int(value.value))

                        resolved_values.append({
                            'value_name': value_name,
                            'base_type': BASE_TYPE_NAME_MAP[type_profile.base_type],
                            'value_str': value_str,
                            'original_value_name': value.name,
                            'comment': value.comment}
                        )

                duplicate_value_names = duplicates([v['value_name'] for v in resolved_values])
                if duplicate_value_names:
                    raise CodeGeneratorError('Type {} has duplicate value names: {}'.format(type_name, ','.join(duplicate_value_names)))

                max_name_length = max([len(resolved_value['value_name']) for resolved_value in resolved_values])
                max_value_length = max([len(resolved_value['value_str']) for resolved_value in resolved_values])
                max_original_name_length = max([len(resolved_value['original_value_name']) for resolved_value in resolved_values])
                fmt = '{:<' + str(max_name_length) + '} = {}({:>' + str(max_value_length) + '})  # {:<' + str(max_original_name_length) + '}'

                for resolved_value in resolved_values:
                    cw.write_fragment(fmt, resolved_value['value_name'], resolved_value['base_type'], resolved_value['value_str'], resolved_value['original_value_name'])
                    if resolved_value['comment']:
                        cw.write(' - {}', resolved_value['comment'])
                    else:
                        cw.write('')

            cw.unindent()
            cw.new_line(2)

    def generate_messages(self):
        cw = self.code_writer
        messages = self.profile.messages

        for message in messages:
            message_name = CodeGenerator.capitalize_type_name(message.name)
            cw.write('@dataclass(frozen=True)')
            cw.write('# FIT message name: {}', message.name)
            cw.write('class {}(Message):', message_name)
            cw.indent()

            resolved_fields = []
            for field in message.fields:
                CodeGenerator.check_valid_name(field.name)

                resolved_field = {
                    'name': field.name,
                    'type': CodeGenerator.capitalize_type_name(BASE_TYPE_NAME_MAP.get(field.type, field.type)),
                    'comment': field.comment,
                    'is_scalar': not field.array,
                }

                if field.type == 'bool':
                    resolved_field['type'] = 'bool'

                if not resolved_field['is_scalar'] and not resolved_field['type'] == 'String':
                    resolved_field['type'] = 'Tuple[{}]'.format(resolved_field['type'])

                resolved_fields.append(resolved_field)

            duplicate_field_names = duplicates([v['name'] for v in resolved_fields])
            if duplicate_field_names:
                raise CodeGeneratorError('Message {} has duplicate value names: {}'.format(message_name, ','.join(duplicate_field_names)))

            max_name_length = max([len(resolved_field['name']) for resolved_field in resolved_fields])
            max_type_length = max([len(resolved_field['type']) for resolved_field in resolved_fields])

            for resolved_field in resolved_fields:
                CodeGenerator.check_valid_name(resolved_field['name'])
                cw.write_fragment('{:<' + str(max_name_length) + '} : {:<' + str(max_type_length) + '}', resolved_field['name'], resolved_field['type'])
                if resolved_field['comment']:
                    cw.write('    # {}', resolved_field['comment'])
                else:
                    cw.write('')

            cw.new_line()
            cw.write('@staticmethod')
            # cw.write('def from_record(record: Record) -> {}:', message_name) TODO type checking
            cw.write('def from_record(record: Record, message_definition: MessageDefinition):')
            cw.indent()
            cw.write('developer_fields = Message.developer_fields_from_record(record, message_definition)')
            cw.write('undocumented_fields = Message.undocumented_fields_from_record(record, message_definition)')
            for resolved_field in resolved_fields:
                cw.write('{} = None', resolved_field['name'])
            cw.write('return {}({})', message_name, ', '.join(['developer_fields', 'undocumented_fields'] + [resolved_field['name'] for resolved_field in resolved_fields]))
            cw.unindent()
            cw.unindent()

            cw.new_line(2)

    @staticmethod
    def capitalize_type_name(name: str) -> str:
        return ''.join(c[0].capitalize() + c[1:] for c in name.split('_'))

    @staticmethod
    def check_valid_name(name: str) -> None:
        if not name:
            raise CodeGeneratorError('Name is empty')
        if keyword.iskeyword(name):
            raise CodeGeneratorError('Name {} is a keyword'.format(name))
        if name[0].isdigit():
            raise CodeGeneratorError('Name {} starts with a digit'.format(name))

    @staticmethod
    def generate(profile: Profile, types_file: str = None, **kwargs) -> str:
        code_generator = CodeGenerator(profile, **kwargs)
        code_generator.generate_full()

        if types_file:
            code_generator.code_writer.write_to_file(types_file)

        return code_generator.code_writer.content
